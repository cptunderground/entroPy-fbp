\chapter{Concepts and Architecture}
As described in the chapter Related Work, SSB is an ID-centric single feed driven environment, where onboarding is challenging. 
This prerequisite changes from the beginning. The basic idea of the Feed Bundling Protocol is to split up this ID-centric environment into replicated feed pairs, where two participants hold at least one of such a pair.  This pair contains the whole dialog between two nodes which have a contract with each other. Similar to the tin can phone from your childhood where you had two cans connected for every friend you want to communicate with. By introducing intermediary service providers, the onboarding happens at contract signing. Clients will have to possibility to connect to new servers via this ISP and create for each server a new feed pair, which is replicated over this very ISP. Since this approach means an enormous amount of feed replications between ISP and server, this feeds get bundled again.

\section{Tin Can Analogy}
This announced system seems very hard to understand but we can simplifiy it. Look at it as a tin can phone from your childhood where on either side you have two cans, strapped together for every friend you want to communicate with. You start with one corded phone to your best friend, the one you trust the most. In one you talk and the can 'saves' everything you say to it, from the other can you can only hear things from your friend, it also saves everything said from your friend. On the other side your friend has the same but can only hear things out of the one can attached to your speaking can and can only talk into the other can, which is connected to your hearing can. This are the replicated feed pairs.\\

Having this, the dialog needs a way or language to express expectations or requests from either side to communicate with each other, where you can declare what you want from each other. Leading to the simplified RPC protocol.\\

After a while it gets boring only talking to this one friend. Luckily, your friend is the coolest kid in school and knows everyone and even tells you about everyone he knows. Then you ask your friend if he could introduce you to his other friends. This introduction process closely simulates real, human social behavior.\\

After your friend has introduced you to one of his friends you and your friend start to build a new tin can phone. But because you are too far away from each other, you cannot just have a cord from one to the other, so your best friend allows you to route the cord through his house. This corresponds to the replication of the feeds over an intermediary connectivity provider.\\

But there is another problem: you are not the only one. After a while, your best friend has so many connections running through his house from all his friends who want to talk to their other friends, that here is an enormous number of strings going to that other friend. The solution is to combine all these strings into one and send all messages through this one, single bundled connection with the information into which tin can it comes at the end. He multiplexes. Given that little story, we can derive concepts and architecture for the tin can phones of the future. 
\section{Contracts}
Given that little story, we see the foundation of the friendship. The friendship between you and your best friend and the friendship between your best friend and his other friend. By the same token, it is the business contracts between the nodes that provide the foundation for the entire connectivity, protocol and bundling. These contracts are to most important building block of the whole thesis since the define the behaviour of the replicated feed pairs,  onboarding mechanics and bundling.

\subsection{Contract Values}
To build the tin can phone, three basic identifiers are needed. First of all you have to trust each other. This corresponds to the whole legal contract between the two parties. Next you need to know your names to label the phone, so you know who you are talking to. These are the public keys. \\

Since everybody in your house can use the tin phone, you also need some sort of code so that your friend knows that it is you who is sending the message and not your mother. These are the private keys. Having tha,t you need your two tin cans and two wires. One can stands for one feed and the wire for the replication. But if you do not know your friend’s address, you do not know where to put that wire, so you need that as well. 

The address, as the name is well chosen, refers to the IP-address. Last but not least, to distinguish all the cans, you label them accordingly. \\

Therefore a contract consists of actual public key, actual private key, actual feed ID and the peers public key, feed ID and location. Since a contract has been established, we need to know what happens in the tin cans and the wire. This leads to the replicated feeds.
\pagebreak

\section{Replicated Feeds}
The following sentence can be exctracted from the SSB API: ”A feed is a signed append-only sequence of messages. Each identity has exactly one feed.\footnote{\url{https://scuttlebot.io/more/protocols/secure-scuttlebutt.html}}” So what do these properties mean? 

\begin{itemize}
    \item igned message: the encryption of plain text with the sender’s private key to a cipher text. The crypto text can be deciphered with the sender’s public key. 
    \item append-only: this sequence can not be forged. So there is no possible way to modify or delete any entries that were appended at any time.\footnote{Feeds - \url{https://ssbc.github.io/scuttlebutt-protocol-guide/}} This append-only property is realized with a hash chain which references the hash value of the previously generated message.\footnote{Feeds - \url{https://ssbc.github.io/scuttlebutt-protocol-guide/}}
    \item dentity - one feed: the previously mentioned ID-centric architecture. Only one identity (key) is mapped feed, where every single bit of information you created or used in the SSB universe is stored. 
\end{itemize}
A simplified diagram can be user to illustrate that there is a lot going on in the SSB feed, but an adapted simplified version is more than sufficient for this thesis. 

\begin{figure}
    \centering
    \includegraphics[width=0.5\textwidth]{feed_schema}
    \caption{A schematic simplified feed.}
    \label{fig:feed_schema}
\end{figure}
What can be derived from this information? Signing ensures that you can trust an identity. The append-only property underlines this trust by guaranteeing completeness of the information read in a feed. ID-centric feeds ensure that this feed belongs to exactly one identity, but there is the sticking point. Since the replication of the SSB protocol always replicates the whole feed to all peers (hops noch angeben) of a single identity, there is a load on the wire for big feeds. This causes latency and long scuttling time (feed update). By splitting the feeds into smaller ones, this can be bypassed and the effective communication between two parties bundled in the feed pairs mentioned previously. As a result, we have a diagram like this: For the sake of clarity, only the situation between the client and the ISP is shown. 

\begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{fbp_v0_1_Schema}
    \caption{Full contract between client and ISP with feeds as it is the same for the server and the ISP as shown.}
    \label{fig:contract_cli_isp}
\end{figure}
The replicator or the replication process has it first appearance. As a concept, there is some sort of replicator instance or procedure that replicates the feeds to the corresponding address or location. But let’s have a closer look at the implementation part. \\
Having this setup, the next step is to have a possibility to communicate, so the client can request information from the ISP’s real database.

\pagebreak
\section{Remote Procedure Call}
General explanaiton of RPC.


Resulting schema of the API and descriptions given above:

\begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{rpc}
    \caption{A Remote Procedure Call by cli001 to isp001.}
    \label{fig:contract_cli_isp}
\end{figure}


Picture description: -> will be splited into above sections

Seen in the picture above, client cli001 makes a request of the echo service with the attribute: String to echo. This is passed to the send\_request function which assigns an unique ID for this request, resulting from the already given ids in the feed pair. Also merges type, id, service, and attributes into a request (a defined datastructure), writes appends this as a new log entry to the feed and saves the ID for keeping track of open requests. isp001 now detects a change on the feed cli001\_isp001 and invokes the read\_request method which takes the request appart and evaluates the service. Now the request gets handled and the wanted value returned. After that send result is invoked. It is similar to the send request, difference is the type and the result is also appended to the result datastructure. Now again, writing a new log entry to the feed with the given content. cli001 is notified that the isp001\_cli001 feed is changed. so read result is invoked and the result gets either to the program, where it was requested or printed to the client.

%\section{v0.2}
%The next step was to include servers with services. Also here the Prerequisite and contract situation changed.
\section{Introducing and Detrucing}
\subsection{Introducing}
Recapping the tin can phone story: The idea of introducing is to get in touch with a new friend, to whom your best friend introduces you. You and your new friend create a new tin can phone. Since the cord is only long enough to reach your best friend, he connects you to your newly acquired friend. Therefore, the general idea of introducing in context of the feed bundling protocol, is onboarding to a new server over your ISP. This approach differs from the common publish and subscribe (pub-sub) architecture. Where the server has no choice to decline a client in the pub-sub model, this is the foundation of the introduce-detruce model. As we were talking of rpc before, in either way accept or decline an answer is provided to the client, else it would violate the rpc clauses.

A more detailed description: cli001 sends an RPC request to the introduce service of his ISP. This request needs an attribute which specifies the server which the client wants to be intrduced to. In this particular case ser001. isp001 invokes the introduce service, which now makes an RPC request with information about the client and the fact that it wants to introduce itself to ser001. and sends this to the server. The server has the choice to either accept or decline the introduce inquiry. If ser001 accepts the introduction, it will directly create the feed pair on its side of the two tin cans. Afterwards, it sends a confirmation or acceptance back to the ISP. Additionally to just the statement that the client was accepted the whole contract information for client is given by server: feed ID etc. 
Or the server declines the introducing approach, so the result is rejection followed by no or some sort of empty contract.

Either way isp001 gets the result and passes this result to the initial rpc request. The client now gets his result. Depending to the state of acceptance or rejection it builds its feed pair in accordance with the contract and finally the connection is successfully established. Now if client wants to use a service from server it only writes the request in the corresponding feed and the procedure is the same as described in RPC Section.
\\
An important distinction: only the client can introduce itself. The server has no knowledge of clients and also no way to acquire knowledge of clients, so only the client can ask the server for a contract. 

\subsection{Detrucing}
Detrucing as a newly invented word by me, since normally after you introduced yourself to a person there is no way to make this unhappened. It acts the same as an unfollow in a pub-sub domain. But contrary, to the introduce both parts of the contract can detruce. \\
Either client or server can send an RPC request to the ISP service to detruce, which is propagated to the opposite end descibed above in the Introducing section and results in the terminaton of the whole contract. The result of this action is deleting keys and feeds. There is no way to decline a detruce service request.
\\
An important note: after detrucing from either side, the client can yet again introduce itself to the server.
\\
A new diagram of the network can be derived using these descriptions.
\begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{intro_detru}
    \caption{State after accepted introduce from cli001 to ser001}
    \label{fig:contract_cli_isp}
\end{figure}

\pagebreak

%\section{0.4}
%added indirect communication from client to server over ISP\\
\section{Bundling}
taking again a look at the real world problem the isp has arbitrary many clients and many of them want to cumminicate with the same server. Idea: bundling all e2e feeds to same server into isp-server feed.
-> load on wire problem

\subsection{Adapted Introducing and Detrucing}
introducing to server same - after server accept server generates both feeds request and result feed - sends contract to isp and isp generates result feed and replicates to cli - finally client generates request feed and replicates to isp.


\subsection{Multiplexing and Demultiplexing}
requests from client same way to isp. but isp does not replicate feed anymore. it takes whole log entry, signed by client and mulutiplexes into a new log entry with a mux type content and signs this - mutliplexing. at server, server takes this mux type and extracts whole request feed entry and appends bytes to request feed from client - demultiplexing. handles request and writes result to result feed. from there the whole entry gets again multiplexed in the ispser feed. at isp isp demux entry and also appends bytewise to result feed. replicates to cli and cli can use result.

Resulting Schema:

\begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{mux_schema}
    \caption{multiplexing}
    \label{fig:mux}
\end{figure}

\section{Outlook}
\subsection{P2P ISP Nodes}
\subsection{Contract between ISPs}